import numpy as np
from scipy.stats import norm
import cv2
import random
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import random


def random_invert_image(x, probability_invert=0.2):
    """
    Invert an image with a given probability
    """
    if random.random() > probability_invert:
        return x
    return 255 - x  # Invert image


def random_white_balance(x, strength_range=(0.8, 1.2)):
    """
    Simulates poor white balance by randomly scaling RGB channels independently.
    strength_range controls how strong the color cast distortion is.
    """
    x = x.astype(np.float32)

    # Random scaling for each channel (simulates color cast)
    r_scale = np.random.uniform(*strength_range)
    g_scale = np.random.uniform(*strength_range)
    b_scale = np.random.uniform(*strength_range)

    x[..., 0] *= r_scale  # Red channel
    x[..., 1] *= g_scale  # Green channel
    x[..., 2] *= b_scale  # Blue channel

    return x


def add_noise(img):
    '''Add random noise to an image'''
    VARIABILITY = 3
    deviation = VARIABILITY*random.random()
    noise = np.random.normal(0, deviation, img.shape)
    img += noise
    np.clip(img, 0., 255.)
    return img


## https://medium.com/@fanzongshaoxing/adjust-local-brightness-for-image-augmentation-8111c001059b
def generate_spot_light_mask(mask_size,
                             position=None,
                             max_brightness=255,
                             min_brightness=0,
                             mode="gaussian",
                             linear_decay_rate=None,
                             speedup=False):
    """
    Generate decayed light mask generated by spot light given position, direction. Multiple spotlights are accepted.
    Args:
        mask_size: tuple of integers (w, h) defining generated mask size
        position: list of tuple of integers (x, y) defining the center of spotlight light position,
                  which is the reference point during rotating
        max_brightness: integer that max brightness in the mask
        min_brightness: integer that min brightness in the mask
        mode: the way that brightness decay from max to min: linear or gaussian
        linear_decay_rate: only valid in linear_static mode. Suggested value is within [0.2, 2]
        speedup: use `shrinkage then expansion` strategy to speed up vale calculation
    Return:
        light_mask: ndarray in float type consisting value from max_brightness to min_brightness. If in 'linear' mode
                    minimum value could be smaller than given min_brightness.
    """
    if position is None:
        position = [(random.randint(0, mask_size[0]), random.randint(0, mask_size[1]))]
    if linear_decay_rate is None:
        if mode == "linear_static":
            linear_decay_rate = random.uniform(0.25, 1)
    assert mode in ["linear", "gaussian"], \
        "mode must be linear_dynamic, linear_static or gaussian"
    mask = np.zeros(shape=(mask_size[1], mask_size[0]), dtype=np.float32)
    if mode == "gaussian":
        mu = np.sqrt(mask.shape[0]**2+mask.shape[1]**2)
        dev = mu / 3.5
        mask = _decay_value_radically_norm_in_matrix(mask_size, position, max_brightness, min_brightness, dev)
    mask = np.asarray(mask, dtype=np.uint8)
    # add median blur
    mask = cv2.medianBlur(mask, 5)
    mask = 255 - mask
    # cv2.imshow("mask", mask)
    # cv2.waitKey(0)
    return mask

def _decay_value_radically_norm_in_matrix(mask_size, centers, max_value, min_value, dev):
    """
    _decay_value_radically_norm function in matrix format
    """
    center_prob = norm.pdf(0, 0, dev)
    x_value_rate = np.zeros((mask_size[1], mask_size[0]))
    for center in centers:
        coord_x = np.arange(mask_size[0])
        coord_y = np.arange(mask_size[1])
        xv, yv = np.meshgrid(coord_x, coord_y)
        dist_x = xv - center[0]
        dist_y = yv - center[1]
        dist = np.sqrt(np.power(dist_x, 2) + np.power(dist_y, 2))
        x_value_rate += norm.pdf(dist, 0, dev) / center_prob
    mask = x_value_rate * (max_value - min_value) + min_value
    mask[mask > 255] = 255
    return mask



def add_spot_light(image, light_position=None, max_brightness=255, min_brightness=0,
                   mode='gaussian', linear_decay_rate=None, transparency=None):
    """
    Add mask generated from spot light to given image
    """
    image = image.astype(np.uint8)  # neue Zeile
    if transparency is None:
        transparency = random.uniform(0.2, 0.75)
    frame = image
    height, width, _ = frame.shape
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    mask = generate_spot_light_mask(mask_size=(width, height),
                                    position=light_position,
                                    max_brightness=max_brightness,
                                    min_brightness=min_brightness,
                                    mode=mode,
                                    linear_decay_rate=linear_decay_rate)
    hsv[:, :, 2] = hsv[:, :, 2] * transparency + mask * (1 - transparency)
    frame = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)
    frame[frame > 255] = 255
    frame = np.asarray(frame, dtype=np.uint8)
    return frame



def invert(imagem):
    if (random.getrandbits(1)):
        return (255)-imagem
    else:
        return imagem

def blur(img):
    k = random.randint(0,3)
    if (k>0):
        return (cv2.blur(img,(3,3)))
    else:
        return img

def preprocessing(img):
    #if (random.getrandbits(1)):
    #    img = blur(img)
    if (random.getrandbits(1)):
        img = add_spot_light(img).astype(np.float32)
    img = invert(img)
    img = add_noise(img)
    
    return img



Width_Shift_Range_Default = 3 # px
Height_Shift_Range_Default = 0 # px
Brightness_Range_Default = [0.4,1.2]
Rotation_Angle_Default = 5
ZoomRange_Out_Default = 0
ZoomRange_In_Default = 0
ShearRange_Default= 3
Channel_Shift_Default=0.4
Batch_Size_Default = 32

def augmentation(x, y, _Batch_Size    = Batch_Size_Default, 
                 _width_shift_range   = Width_Shift_Range_Default, 
                 _height_shift_range  = Height_Shift_Range_Default,
                 _brightness_range    = Brightness_Range_Default,
                 _zoom_range_In       = ZoomRange_In_Default,
                 _zoom_range_Out      = ZoomRange_Out_Default,
                 _rotation_range      = Rotation_Angle_Default,
                 _channel_shift_range = Channel_Shift_Default,
                 _shear_range         = ShearRange_Default,
                 _preprocessing       = True):
    
    if _preprocessing:
        datagen = ImageDataGenerator(width_shift_range=_width_shift_range, 
                                 height_shift_range=_height_shift_range,
                                 brightness_range=_brightness_range,
                                 zoom_range=[1-_zoom_range_In, 1+_zoom_range_Out],
                                 rotation_range=_rotation_range,
                                 channel_shift_range=_channel_shift_range,
                                 fill_mode='nearest',
                                 shear_range=_shear_range,
                                 preprocessing_function=preprocessing,
                                 dtype=float)
    else:
        datagen = ImageDataGenerator(width_shift_range=_width_shift_range, 
                                 height_shift_range=_height_shift_range,
                                 brightness_range=_brightness_range,
                                 zoom_range=[1-_zoom_range_In, 1+_zoom_range_Out],
                                 rotation_range=_rotation_range,
                                 channel_shift_range=_channel_shift_range,
                                 fill_mode='nearest',
                                 shear_range=_shear_range,
                                 dtype=float)
    return datagen.flow(x, y, batch_size=_Batch_Size)
    
def no_augmentation(x, y, Batch_Size = 32):
    datagen = ImageDataGenerator(dtype=float)
    return datagen.flow(x, y, batch_size=Batch_Size)